{
  "name": "cloud",
  "version": "1.3.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/segmentio/cloud"
  },
  "description": "remote scripting like capistrano / fabric for managing clusters",
  "keywords": [
    "capistrano",
    "remote",
    "cluster",
    "fabric",
    "ssh"
  ],
  "dependencies": {
    "co-exec": "~1.1.0",
    "co": "~3.0.2",
    "commander": "~2.1.0",
    "printf": "~0.1.2",
    "batch": "~0.5.0",
    "shell-escape": "0.0.1"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*"
  },
  "license": "MIT",
  "readme": "\n# cloud\n\n  Remote execution with VPC support, kinda like fabric/capistrano for\n  node with greater scripting control via generators.\n\n  [![Build Status](https://magnum.travis-ci.com/segmentio/cloud.png?token=exthRyNRTLjkmpmb4FUi&branch=master)](https://magnum.travis-ci.com/segmentio/cloud)\n\n## Installation\n\n```\n$ npm install cloud\n```\n\n## Usage\n\n```\n  Usage: cloud <task ...>\n\n  Options:\n\n    -h, --help             output usage information\n    -D, --dry-run          perform a dry run\n    -t, --tasks            output list of available tasks\n    -H, --hosts            output list of available hosts\n    -v, --verbose          output verbose log information\n    -c, --concurrency <n>  task execution concurrency [1]\n```\n\n## Guide\n\n  When `cloud.parse(argv)` is run it turns your script into\n  a CLI, so flags such as `--help` and `--tasks` are available,\n  and arguments may be passed to execute tasks.\n\n  Here's a contrived example that runs `hostname` on private hosts\n  in a VPC:\n\n```js\nvar Cloud = require('cloud');\n\nvar c = new Cloud;\n\nvar stage = c.host('stage', {\n  key: '~/.ec2/my.pem',\n  user: 'ec2-user',\n  address: 'n.n.n.n'\n});\n\nc.task('stage', 'stage everything', ['stage:site', 'stage:api', 'stage:ingestion']);\n\nc.task('stage:site', 'stage site', function *(){\n  console.log(yield stage.exec('hostname'));\n});\n\nc.task('stage:api', 'stage api', function *(){\n  console.log(yield stage.exec('hostname', 'api'));\n});\n\nc.task('stage:ingestion', 'stage ingestion', function *(){\n  console.log(yield stage.exec('hostname', 'ingestion'));\n});\n\nc.parse(process.argv);\n```\n\n### Listing tasks\n\n  To list tasks use the `-t, --tasks` flag:\n\n```\nnode --harmony cloud -t\n\n             stage — stage everything\n        stage:site — stage site\n         stage:api — stage api\n   stage:ingestion — stage ingestion\n\n```\n\n### Executing commands\n\n  Executing remote commands is simple, just execute `host.exec(command)`, optionally\n  passing a private hostname to execute on a private host:\n\n```js\nvar uptime = yield stage.exec('uptime');\nvar uptime = yield stage.exec('uptime', 'api-1');\nvar uptime = yield stage.exec('uptime', 'api-2');\nvar uptime = yield stage.exec('uptime', 'api-3');\n```\n\n  If you're running many commands on a private host, you may want\n  to create a new `Host` object to reference it, for example the\n  following are equivalent:\n\n```js\nvar a = yield stage.exec('foo', 'api-1');\nvar b = yield stage.exec('bar', 'api-1');\nvar c = yield stage.exec('baz', 'api-1');\n\nvar api = stage.host('api-1');\nvar a = yield api.exec('foo');\nvar b = yield api.exec('bar');\nvar c = yield api.exec('baz');\n```\n\n  Since cloud uses Co you may also execute in parallel:\n\n```js\nvar res = yield [\n  stage.exec('uptime', 'api-1'),\n  stage.exec('uptime', 'api-2')\n];\n\nvar uptime1 = res[0];\nvar uptime2 = res[1];\n```\n\n  Or assign to an object:\n\n```js\nvar uptimes = {\n  api1: stage.exec('uptime', 'api-1'),\n  api2: stage.exec('uptime', 'api-2')\n};\n```\n\n### Executing shell scripts\n\n  To execute shell scripts from local disk use the `host.run(script)` method:\n\n```js\nyield stage.run('provision.sh');\n```\n\n  You may also specify a private host just like `host.exec()`:\n\n```js\nyield stage.run('provision.sh', 'api-1');\nyield stage.run('provision.sh', 'api-2');\nyield stage.run('provision.sh', 'api-3');\n```\n\n### Executing dependencies\n\n  One method of defining dependencies is by passing an array\n  as shown in the following example:\n\n```js\nc.task('stage', 'stage everything', ['stage:site', 'stage:api', 'stage:ingestion']);\n```\n\n  You may also utilize `c.task(name)` to execute programmatically:\n\n```js\nc.task('stage', 'stage everything', function *(){\n  yield c.task('stage:api');\n  yield c.task('stage:site');\n  yield c.task('stage:ingestion');\n});\n```\n\n  This gives you greater control over flow and concurrency, for example\n  the last two will run in parallel:\n\n```js\nc.task('stage', 'stage everything', function *(){\n  yield c.task('stage:site');\n\n  yield [\n    c.task('stage:api'),\n    c.task('stage:ingestion'),\n  ];\n});\n```\n\n### Setting context variables\n\n  The `this` variable becomes a `Context` which holds all of the values\n  defined via the `-s, --set` flag. For example `-s version=1.2.0` will\n  provide `this.version == \"1.2.0\"`, and `-s debug` will set `this.debug == true`.\n\n  You may also omit the `-s` flag entirely when a value is supplied, for example\n  the follow would be equivalent.\n\n```\n$ mycommand site:run -s cmd=uptime\n$ mycommand site:run cmd=uptime\n```\n\n# License\n\n  MIT",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/segmentio/cloud/issues"
  },
  "homepage": "https://github.com/segmentio/cloud",
  "_id": "cloud@1.3.1",
  "dist": {
    "shasum": "1a47b32230bbf89da0a7878a48b16771ea5ac93c"
  },
  "_from": "cloud@",
  "_resolved": "https://registry.npmjs.org/cloud/-/cloud-1.3.1.tgz"
}
